/*
 * This file is part of MIN Test Framework. Copyright Â© 2008 Nokia Corporation
 * and/or its subsidiary(-ies).
 * Contact: Robert Galkowski
 * Contact e-mail: DG.MIN-Support@nokia.com
 * 
 * This program is free software: you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by the Free 
 * Software Foundation, version 2 of the License. 
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General  Public License for
 * more details. You should have received a copy of the GNU General Public 
 * License along with this program. If not,  see 
 * <http://www.gnu.org/licenses/>.
 */


/**
 *  @file       tec.c
 *  @version    0.1
 *  @brief      This file contains implementation of test execution 
 *              controller functionality
 */

/* ----------------------------------------------------------------------------
 * INCLUDE FILES
 */
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/wait.h>
#include <dirent.h>
#include <sys/stat.h>

#include <min_parser.h>
#include <tec.h>
#include <min_common.h>
#include <treport_log.h>
#include <consoleui.h>
#include <data_api.h>
#include <tec_events.h>
#include <min_logger.h>
#include <min_engine_api.h>

/* ----------------------------------------------------------------------------
 * GLOBAL VARIABLES
 */
pthread_mutex_t tec_mutex_ = PTHREAD_MUTEX_INITIALIZER;
char          **envp;
#ifdef MIN_UNIT_TEST
int             unit_test_result;
#endif                          /*MINMIN_UNIT_TEST */
extern DLList  *ms_assoc;
extern DLList  *EXTIF_received_data;
struct logger_settings_t logger_settings;
eapiIn_t in;

/* ----------------------------------------------------------------------------
 * EXTERNAL DATA STRUCTURES
 * None
 */


/* ---------------------------------------------------------------------------
 * EXTERNAL FUNCTION PROTOTYPES
 */
extern int      ec_msg_ms_handler (MsgBuffer * message);
extern int      ec_msg_sndrcv_handler (MsgBuffer * message);
extern int      event_system_up (void);
extern int      event_system_cleanup (void);

/* ----------------------------------------------------------------------------
 * CONSTANTS
 */

/* ----------------------------------------------------------------------------
 * MACROS
 */

#ifndef MIN_CONF_DIR
# define MIN_CONF_DIR "/etc"
#endif

#ifndef MIN_BIN_DIR
# define MIN_BIN_DIR "/usr/bin"
#endif


/* ----------------------------------------------------------------------------
 * LOCAL CONSTANTS AND MACROS
 */
/* None */

/* ----------------------------------------------------------------------------
 * MODULE DATA STRUCTURES
 */
/* None */

/* ----------------------------------------------------------------------------
 * LOCAL FUNCTION PROTOTYPES
 */
/* ------------------------------------------------------------------------- */
/** Waits for process to be ended - collects the zombie.
 */
LOCAL void      wait_for_pid (void *pid);
/* ------------------------------------------------------------------------- */
/** Signal handler to signal SIGSEGV
 * FATAL. Segmentation violation
 * @param signum signal number
 */
LOCAL void      handle_sigsegv (int signum);
/* ------------------------------------------------------------------------- */
/** Signal handler to signal SIGQUIT
 * FATAL. Process should dump core on this signal.
 * @param signum signal number
 */
/* ------------------------------------------------------------------------- */
LOCAL void      handle_sigquit (int signum);
/** Signal handler to signal SIGBUS
 * FATAL. Bus error.
 * @param signum signal number
 */
/* ------------------------------------------------------------------------- */
LOCAL void      handle_sigbus (int signum);
/** Signal handler to signal SIGTERM
 * Signal generated by (kill <processnumber>)
 * @param signum signal number
 */
/* ------------------------------------------------------------------------- */
LOCAL void      handle_sigterm (int signum);
/** Signal handler to signal SIGINT
 * Signal generated by CTRL-C
 * @param signum signal number
 */
/* ------------------------------------------------------------------------- */
LOCAL void      handle_sigint (int signum);
/** Signal handler for SIGCHLD
 * @param signum signal number
 */
/* LOCAL void handle_sigchld (int signum); not used */
/** Function that wraps test module controller process starting. 
 * In case of failure to start
 * a module, information will be logged.
 * @param work_module_item item from available modules list
 * @return pid of newly created process, or -1 in case of failure
 */
LOCAL pid_t     ec_start_tmc (DLListIterator work_module_item);
/** Parses the module configuration section(s) from the min configuraion file 
 *  @param inifile the min configuration file 
 *  @return 0, always
 */
LOCAL int       ec_read_module_section (MinParser * inifile);
/* ------------------------------------------------------------------------- */
/** Looks for files in directory /etc/min.d and tries to find module
 *  configurations from them
 *  @return 1 if the directory /etc/min.d does not exists or an error occurs,
 *          0 otherwise
 */
LOCAL int       ec_read_module_confdir (void);

/* -------------------------------------------------------------------------
 * FORWARD DECLARATIONS
 */
/* None */

/* ==================== LOCAL FUNCTIONS ==================================== */
/* ------------------------------------------------------------------------- */
LOCAL void wait_for_pid (void *arg)
{
        //int* pid = (int*)arg;
        pthread_exit (0);
}

/* ------------------------------------------------------------------------- */
/*temp code for summary generation*/
void log_summary ()
{
        DLListIterator  work_result_item = INITPTR;
        DLListIterator  work_case_item = INITPTR;
        DLListIterator  work_module_item = INITPTR;

        char           *case_title = NEW2 (char, MaxTestCaseName);
        char           *module_name = NEW2 (char, MaxFileName);
        min_log_open ("SUMMARY", 1);

        MIN_DEBUG (">>>>>>>>>>>>>>>SUMMARY<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");

        work_module_item = dl_list_head (available_modules);
        while (work_module_item != DLListNULLIterator) {
                tm_get_module_filename (work_module_item, module_name);
                MIN_DEBUG ("module: %s", module_name);
                work_case_item =
                    dl_list_head (tm_get_tclist (work_module_item));
                while (work_case_item != DLListNULLIterator) {
                        tc_get_title (work_case_item, case_title);
                        MIN_DEBUG ("case: %s", case_title);
                        work_result_item =
                            dl_list_head (tc_get_tr_list (work_case_item));
                        while (work_result_item != DLListNULLIterator) {
                                MIN_DEBUG ("result = %d",
                                            tr_get_result_type
                                            (work_result_item));
                                work_result_item =
                                    dl_list_next (work_result_item);
                        }
                        work_case_item = dl_list_next (work_case_item);
                }
                work_module_item = dl_list_next (work_module_item);
        }
        MIN_DEBUG (">>>>>>>>>>>>>>>END OF SUMMARY<<<<<<<<<<<<<<<<<<<<<");
        DELETE (module_name);
        DELETE (case_title);
        min_log_close ();

}

int log_summary_stdout ()
{
        DLListIterator  mod_it, case_it;
        filename_t      mod_name;
        int             num_failed = 0;
        min_test_report_begin ();

        for (mod_it = dl_list_head (available_modules);
             mod_it != DLListNULLIterator; mod_it = dl_list_next (mod_it)) {
                tm_get_module_filename (mod_it, mod_name);
                for (case_it = dl_list_head (tm_get_tclist (mod_it));
                     case_it != DLListNULLIterator;
                     case_it = dl_list_next (case_it)) {
                        num_failed += min_test_report_result (case_it, 
                                                               mod_name);
                }
        }
        
        return num_failed;
}

/*end of temp code*/
/**Function used to select test case for execution - passed test case is 
 * copied, and then copied case is added to  "selected" list. As this function 
 * modifies "selected" list, code that calls it should first lock "tec_mutex_",
 * and unlock it after executing the function.
 * @param work_case_item DLList item containing selected case
 * @param group_id id of group to which case belongs
 * @return item from "selected cases" list
 */
DLListIterator ec_select_case (DLListIterator work_case_item, int group_id)
{


        test_case_s    *dest_case = INITPTR;
        test_result_s  *test_result = INITPTR;
        DLListIterator  selected_case = DLListNULLIterator;
        filename_t      config;
        title_string_t  title;
        DLListIterator  work_result_item = DLListNULLIterator;

        tc_get_cfg_filename (work_case_item, config);
        tc_get_title (work_case_item, title);

        dest_case =
            tc_create (tc_get_test_module_ptr (work_case_item), config,
                       title);
        selected_case = tc_add (selected_cases, dest_case);

        tc_set_group_id (selected_case, group_id);
        tc_set_id (selected_case, tc_get_id (work_case_item));
        tc_set_priority (work_case_item, tc_get_priority (work_case_item));

        test_result = tr_create_data_item (selected_case);
        work_result_item =
            tr_add (tc_get_tr_list (selected_case), test_result);

        return selected_case;
}

/*---------------------------------------------------------------------------*/

/** Function used to create shared memory segment and write settings to it, 
 * so that they can be used by other processes (TMCs). Currently sent settings
 *  are: logger's settings placed in apropriate structure, and search paths 
 * (if there are any search paths defined), concatenated into one 
 *  NULL-terminated string, separated by ":" character. If program fails to 
 * createshared memory segment, it will exit the application.
 */
LOCAL void ec_settings_send ()
{

        int             shared_segm_id = 0;
        void           *sh_mem_handle = NULL;
        int             paths_size = 0;
        char           *work_path = INITPTR;
        DLListIterator  work_path_item = DLListNULLIterator;
        char           *concat_paths = INITPTR;
        void           *temp_ptr;
        work_path_item = dl_list_head (ec_settings.search_dirs);

        while (work_path_item != DLListNULLIterator) {

                work_path = (char *)dl_list_data (work_path_item);
                paths_size = paths_size + strlen (work_path) + 1;
                work_path_item = dl_list_next (work_path_item);

        }

        if (paths_size > 0) {
                concat_paths = NEW2 (char, paths_size);
                *concat_paths = '\0';
                work_path_item = dl_list_head (ec_settings.search_dirs);
                while (work_path_item != DLListNULLIterator) {
                        work_path = (char *)dl_list_data (work_path_item);
                        strcat (concat_paths, work_path);
                        work_path_item = dl_list_next (work_path_item);
                        if (work_path_item != DLListNULLIterator)
                                strcat (concat_paths, ":");
                }
        }
        /*create shared memory segment */
        shared_segm_id =
            sm_create ('a', sizeof (struct logger_settings_t) + paths_size);
        if (shared_segm_id < 0) {
                MIN_FATAL ("Failed to create shared memory segment: %s",
                            strerror (errno));
                min_log_close ();
                exit (0);
        }

        ec_settings.sh_mem_id_ = shared_segm_id;
        sh_mem_handle = sm_attach (shared_segm_id);
        sm_write (sh_mem_handle,
                  (void *)(&logger_settings),
                  sizeof (struct logger_settings_t));
        temp_ptr = sh_mem_handle + sizeof (struct logger_settings_t);
        if (paths_size > 0) {
                sm_write (temp_ptr, (void *)concat_paths, paths_size);
                DELETE (concat_paths);
        }

        sm_detach (sh_mem_handle);
}


/*---------------------------------------------------------------------------*/
/** Function used to read logger settings. It was moved to separate function to
 * keep functions shorter. It uses section andf item parser functionalities to
 * write data to logger settings struct.
 * @param section fetched from config file
*/
LOCAL void ec_get_logger_settings (MinSectionParser * settings)
{
        MinItemParser *linebreaker = INITPTR;  /* used if it is necessary 
                                                   to breakdown line into
                                                   parts */
        char           *opt_val = NULL; /* used to hold option value if 
                                         * it is single */
        int             fresult = 0;

        fresult = mmp_get_line (settings,
                                "CreateLogDirectories=", &opt_val, ESNoTag);
        if (fresult == 0) {
		logger_settings.is_defined_.create_log_dir_ = ESTrue;
                if (strcasecmp (opt_val, "YES") == 0) {
                        logger_settings.create_log_dir_ = ESTrue;
                } else if (strcasecmp (opt_val, "NO") == 0) {
                        logger_settings.create_log_dir_ = ESFalse;
                } else {
                        MIN_WARN ("Error in config file (CreateLogDirectories) !");
			logger_settings.is_defined_.create_log_dir_ = ESFalse;
                }
                DELETE (opt_val);
        }

        fresult = mmp_get_line (settings,
                                "EmulatorBasePath=", &opt_val, ESNoTag);
        if (fresult == 0) {
                sprintf (logger_settings.emulator_path_, "%s", opt_val);
                logger_settings.is_defined_.path_ = ESTrue;
                DELETE (opt_val);
        }

        linebreaker = mmp_get_item_line (settings,
                                         "EmulatorFormat=", ESNoTag);

        if (linebreaker != INITPTR) {
                fresult = mip_get_string (linebreaker, "", &opt_val);
                while (fresult == 0) {
                        if (strcasecmp (opt_val, "HTML") == 0) {
                                logger_settings.emulator_format_ =
                                    logger_settings.emulator_format_ | ESHtml;
                                logger_settings.is_defined_.format_ = ESTrue;
                        }
                        if (strcasecmp (opt_val, "TXT") == 0) {
                                logger_settings.emulator_format_ =
                                    logger_settings.emulator_format_ | ESTxt;
                                logger_settings.is_defined_.format_ = ESTrue;
                        }
                        if (strcasecmp (opt_val, "DATA") == 0) {
                                logger_settings.emulator_format_ =
                                    logger_settings.emulator_format_ | ESData;
                                logger_settings.is_defined_.format_ = ESTrue;
                        }
                        DELETE (opt_val);
                        fresult = mip_get_next_string (linebreaker, &opt_val);
                }
        }

        mip_destroy (&linebreaker);
        linebreaker = mmp_get_item_line (settings,
                                         "EmulatorOutput=", ESNoTag);

        if (linebreaker != INITPTR) {
                fresult = mip_get_string (linebreaker, "", &opt_val);
                while (fresult == 0) {
                        if (strcasecmp (opt_val, "NULL") == 0) {
                                logger_settings.emulator_output_ =
                                    logger_settings.emulator_output_ | ESNull;
                                logger_settings.is_defined_.output_ = ESTrue;
                        }
                        if (strcasecmp (opt_val, "FILE") == 0) {
                                logger_settings.emulator_output_ =
                                    logger_settings.emulator_output_ | ESFile;
                                logger_settings.is_defined_.output_ = ESTrue;
                        }
                        if (strcasecmp (opt_val, "SYSLOG") == 0) {
                                logger_settings.emulator_output_ =
                                    logger_settings.
                                    emulator_output_ | ESSyslog;
                                logger_settings.is_defined_.output_ = ESTrue;
                        }

                        DELETE (opt_val);
                        fresult = mip_get_next_string (linebreaker, &opt_val);
                }

        }

        mip_destroy (&linebreaker);

        fresult = mmp_get_line (settings,
                                "ThreadIdToLogFile=", &opt_val, ESNoTag);
        if (fresult == 0) {
		logger_settings.is_defined_.pidid_ = ESTrue;
                if (strcasecmp (opt_val, "YES") == 0) {
                        logger_settings.pidid_ = ESTrue;
                } else if (strcasecmp (opt_val, "NO") == 0) {
                        logger_settings.pidid_ = ESFalse;
                } else {
                        MIN_WARN ("Error in config file (ThreadIdToLogFile) !");
			logger_settings.is_defined_.pidid_ = ESFalse;
                }
                DELETE (opt_val);
        }

        fresult = mmp_get_line (settings,
                                "WithTimeStamp=", &opt_val, ESNoTag);
        if (fresult == 0) {
		logger_settings.is_defined_.time_stamp_ = ESTrue;
                if (strcasecmp (opt_val, "YES") == 0) {
                        logger_settings.time_stamp_ = ESTrue;
                } else if (strcasecmp (opt_val, "NO") == 0) {
                        logger_settings.time_stamp_ = ESFalse;
                } else {
                        MIN_WARN ("Error in config file (WithTimeStamp) !");
			logger_settings.is_defined_.time_stamp_ = ESFalse;
                }
                DELETE (opt_val);
        }

        fresult = mmp_get_line (settings,
                                "WithLineBreak=", &opt_val, ESNoTag);
        if (fresult == 0) {
		logger_settings.is_defined_.line_break_ = ESTrue;
                if (strcasecmp (opt_val, "YES") == 0) {
                        logger_settings.line_break_ = ESTrue;
                } else if (strcasecmp (opt_val, "NO") == 0) {
                        logger_settings.line_break_ = ESFalse;
                } else {
                        MIN_WARN ("Error in config file (WithLineBreak) !");
			logger_settings.is_defined_.line_break_ = ESFalse;
                }

                DELETE (opt_val);
        }

        fresult = mmp_get_line (settings,
                                "WithEventRanking=", &opt_val, ESNoTag);
        if (fresult == 0) {
		logger_settings.is_defined_.event_ranking_ = ESTrue;
                if (strcasecmp (opt_val, "YES") == 0) {
                        logger_settings.event_ranking_ = ESTrue;
                } else if (strcasecmp (opt_val, "NO") == 0) {
                        logger_settings.event_ranking_ = ESFalse;
                } else {
                        MIN_WARN ("Error in config file (WithEventRanking) !");
			logger_settings.is_defined_.event_ranking_ = ESFalse;
                }

                DELETE (opt_val);
        }

        fresult = mmp_get_line (settings,
                                "FileCreationMode=", &opt_val, ESNoTag);
        if (fresult == 0) {
		logger_settings.is_defined_.overwrite_ = ESTrue;
                if (strcasecmp (opt_val, "APPEND") == 0) {
                        logger_settings.overwrite_ = ESFalse;
                } else if (strcasecmp (opt_val, "OVERWRITE") == 0) {
                        logger_settings.overwrite_ = ESTrue;
                } else {
			logger_settings.is_defined_.overwrite_ = ESFalse;
                        MIN_WARN ("Error in config file (FileCreationMode) !");
                }

                DELETE (opt_val);
        }
        
        fresult = mmp_get_line (settings,
                                "LogLevel=", &opt_val, ESNoTag);
        if (fresult == 0) {
                if (strcasecmp (opt_val, "fatal") == 0) {
                        logger_settings.loglevel_ = ESFatal;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else if (strcasecmp (opt_val, "error")==0) {
                        logger_settings.loglevel_ = ESError;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else if (strcasecmp (opt_val, "warn")==0) {
                        logger_settings.loglevel_ = ESWarning;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else if (strcasecmp (opt_val, "info")==0) {
                        logger_settings.loglevel_ = ESInfo;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else if (strcasecmp (opt_val, "notice")==0) {
                        logger_settings.loglevel_ = ESNotice;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else if (strcasecmp (opt_val, "debug")==0) {
                        logger_settings.loglevel_ = ESDebug;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else if (strcasecmp (opt_val, "trace")==0) {
                        logger_settings.loglevel_ = ESTrace;
                        logger_settings.is_defined_.loglevel_ = ESTrue;
                } else {
                        MIN_WARN ("Error in config file (LogLevel) !");
                }
                DELETE (opt_val);
        }
}

/**Function used for temporary module instantiation and test case execution, 
 * used when there is a need to execute two test cases from the same module 
 * in parallel.
 * @param work_case_item DLListItem containing test case to be executed
 */
LOCAL int ec_start_module_temp (DLListIterator work_case_item)
{
	/* this will be the module that will be used as a source of data for 
	 * instantiating temporary module */
        DLListIterator  source_module_item = DLListNULLIterator;        
	/* this will contain handle to temporaryily instantiated module */
        DLListIterator  temporary_module_item = DLListNULLIterator;    
        /* we will need also the copy of case to be executed */
        DLList         *work_cases_list = dl_list_create ();
        DLList         *cfgs_work_list = dl_list_create ();
        pid_t           temp_mod_pid = 0;
        filename_t      library_name;
        test_module_info_s *temporary_module = INITPTR;

        source_module_item = tc_get_test_module_ptr (work_case_item);

        tm_get_module_filename (source_module_item, library_name);

        temporary_module =
            tm_create (library_name,
                       tm_get_cfg_filenames (source_module_item),
                       tm_get_module_id (source_module_item));
        temporary_module_item =
            tm_add (instantiated_modules, temporary_module);
        tm_set_cfg_filenames (temporary_module_item, cfgs_work_list);
        temp_mod_pid = ec_start_tmc (temporary_module_item);
        if (temp_mod_pid == -1) {
                MIN_WARN ("Failed to create module");
                return -1;

        }
        tm_set_status (temporary_module_item, TEST_MODULE_INITIALIZED_TEMP);
        tm_set_tclist (temporary_module_item, work_cases_list);
        tm_set_pid (temporary_module_item, temp_mod_pid);

        tc_add (work_cases_list, dl_list_data (work_case_item));
        tc_set_test_module_ptr (work_case_item, temporary_module_item);

        return 1;
}

/*--------------------------------------------------------------------*/

/** Function used to initialize logger_settings structure
*/
LOCAL void ec_init_logger_settings ()
{
        logger_settings.create_log_dir_ = ESFalse;
        logger_settings.unicode_ = ESFalse;
        logger_settings.time_stamp_ = ESFalse;
        logger_settings.pidid_ = ESFalse;
        logger_settings.overwrite_ = ESFalse;
        logger_settings.line_break_ = ESFalse;
        logger_settings.event_ranking_ = ESFalse;
        *logger_settings.emulator_path_ = '\0';
        logger_settings.emulator_output_ = ESNull;
        logger_settings.emulator_format_ = 0;
        logger_settings.is_defined_.create_log_dir_ = ESFalse;
        logger_settings.is_defined_.unicode_ = ESFalse;
        logger_settings.is_defined_.time_stamp_ = ESFalse;
        logger_settings.is_defined_.pidid_ = ESFalse;
        logger_settings.is_defined_.path_ = ESFalse;
        logger_settings.is_defined_.overwrite_ = ESFalse;
        logger_settings.is_defined_.output_ = ESFalse;
        logger_settings.is_defined_.line_break_ = ESFalse;
        logger_settings.is_defined_.hw_path_ = ESFalse;
        logger_settings.is_defined_.hw_output_ = ESFalse;
        logger_settings.is_defined_.hw_format_ = ESFalse;
        logger_settings.is_defined_.format_ = ESFalse;
        logger_settings.is_defined_.event_ranking_ = ESFalse;
}

/*-----------------------------------------------------------------------*/

/** Function called to execute one test case. Prequisite: before calling this
 * function, case should be put in "selected_cases" list, and that's from 
 * where argument should be taken.
 * @param work_case_item pointer to item from "selected_cases" containing 
 *        test case to be executed.
 *  @return result of operation (TBD)
 */
int ec_exec_case (DLListIterator work_case_item)
{

        DLList         *work_result_list = tc_get_tr_list (work_case_item);
        DLListIterator  test_result_item;
        int             work_module_status;
        test_case_s    *work_case = INITPTR;
        MsgBuffer       message;
        int             res = -1;
        DLListIterator  work_module_item =
            tc_get_test_module_ptr (work_case_item);

        if (work_module_item == INITPTR) {
                MIN_DEBUG (" exec case %x", work_case_item);
                MIN_WARN ("Faulty test case data");
                goto EXIT;

        }

        work_case = dl_list_data (work_case_item);

        if (work_case == DLListNULLIterator) {

                MIN_WARN ("Faulty test case data (2)");
                goto EXIT;

        }
        work_module_status = tm_get_status (work_module_item);

        switch (work_module_status) {

        case TEST_MODULE_READY:
                tm_set_status (work_module_item, TEST_MODULE_BUSY);
                tc_set_status (work_case_item, TEST_CASE_ONGOING);
                test_result_item = dl_list_head (work_result_list);
                /* it is enough to get "head of the list, since item in 
		 * selected list is just a copy of test case containing one 
		 * result in the list */
                tr_set_start_time (test_result_item, time (NULL));
                tr_set_priontouts_list (test_result_item, dl_list_create ());
                message.type_ = MSG_EXE;
                message.sender_ = ec_settings.engine_pid_;
                message.receiver_ = tm_get_pid (work_module_item);
                message.param_ = tc_get_id (work_case_item);
                STRCPY (message.desc_, "\0", MaxDescSize);
                tc_get_cfg_filename (work_case_item, message.message_);
                res = mq_send_message (mq_id, &message);
                break;

        case TEST_MODULE_BUSY:
                ec_start_module_temp (work_case_item);
                res = 0;
                break;

        default:
                MIN_WARN ("module status fault");
                res = -1;

        }
EXIT:
        return res;
}




/**Function used to check if there is a test case with given group id 
 * in "selected_cases" list waiting to be executed and runs it if it is the 
 * case.
 * @param group_id - id og group of test cases in question.
*/
LOCAL void ec_check_next_in_group (int group_id)
{

        DLListIterator  work_case_item = DLListNULLIterator;

        pthread_mutex_lock (&tec_mutex_);

        work_case_item = dl_list_head (selected_cases);

        while (work_case_item != DLListNULLIterator) {

                if ((tc_get_group_id (work_case_item) == group_id) &&
                    (tc_get_status (work_case_item) == TEST_CASE_IDLE))
                        break;
                
                work_case_item = dl_list_next (work_case_item);
        }
        
        pthread_mutex_unlock (&tec_mutex_);
        
        if (work_case_item != DLListNULLIterator) {
                ec_exec_case (work_case_item);
        }

        return;
}





/**Function for removal of temporary instantiated module.
 * @param work_module_item pointer to dllistitem containing module in question.
 */
LOCAL int ec_remove_module_temp (DLListIterator work_module_item)
{

        pthread_t       threadid;
        long            address = tm_get_pid (work_module_item);
        test_module_info_s *work_module =
            (test_module_info_s *) dl_list_data (work_module_item);

        mq_send_message2 (mq_id, address, MSG_END, 0, "Shut down !");
#ifndef MIN_UNIT_TEST
        /*waitpid ( address, NULL, 0); */
        pthread_create (&threadid, NULL, (void *)&wait_for_pid,
                        (void *)&address);
#endif
        tm_delete (work_module);
        tm_remove (work_module_item);

        return 0;
}

/**Function used to start test case from temporarily instantianted module -
 * process is slightly different than starting test case from ordinary module.
 * "Temp" module has only one test case in list, so only that has to be passed
 * to this function is module item.
 * @param work_module_item pointer to dllistitem containg "current" module.
*/
LOCAL int ec_exec_case_temp (DLListIterator work_module_item)
{
        MsgBuffer       message;
        DLListIterator  work_result_item;
        DLListIterator  work_case_item =
                dl_list_head (tm_get_tclist (work_module_item));
        test_case_s    *work_case = dl_list_data (work_case_item);

        /*let's look for test case in "selected list" */
        pthread_mutex_lock (&tec_mutex_);

        work_case_item = dl_list_head (selected_cases);

        while (work_case_item != DLListNULLIterator) {

                if (dl_list_data (work_case_item) == work_case)
                        break;
                work_case_item = dl_list_next (work_case_item);

        }

        pthread_mutex_unlock (&tec_mutex_);

        if (work_case_item == DLListNULLIterator) {
                MIN_WARN ("Test case not found in selected list");
                return -1;
        }

        tm_set_status (work_module_item, TEST_MODULE_BUSY_TEMP);
        tc_set_status (work_case_item, TEST_CASE_ONGOING);
        work_result_item = dl_list_head (tc_get_tr_list (work_case_item));
        tr_set_start_time (work_result_item, time (NULL));
        tr_set_priontouts_list (work_result_item, dl_list_create ());

        /*create and send message */
        message.type_ = MSG_EXE;
        message.sender_ = ec_settings.engine_pid_;
        message.receiver_ = tm_get_pid (work_module_item);
        message.param_ = tc_get_id (work_case_item);
        STRCPY (message.desc_, "\0", MaxDescSize);
        tc_get_cfg_filename (work_case_item, message.message_);
        mq_send_message (mq_id, &message);

        return 0;
}

/**Function for handling test results obtained from "temp" module
 * @param temp_module_item DLListIterator containing module to be worked on
 * @param message pointer to received message buffer
 */
LOCAL int ec_handle_temp_results (DLListIterator temp_module_item,
                                  MsgBuffer * message)
{
        /*this module has only one test case */
        DLListIterator  work_case_item =
            dl_list_head (tm_get_tclist (temp_module_item));
        int             group_id = tc_get_group_id (work_case_item);
        DLListIterator  orig_case;
        DLListIterator  work_module_item = DLListNULLIterator;
        DLListIterator  temp_result;
        DLListIterator  work_result_item = DLListNULLIterator;
        test_result_s  *work_result = INITPTR;
        filename_t      name;
        filename_t      name2;
        filename_t      work_conf;
        filename_t      orig_conf;
        int             id, id2;
        int             result = 0;
        int             it = 1; /*general purpose loop iterator */

        int             orig_case_no = 0;       /*id for external controller */
        int             cont_flag = 1;
#ifdef MIN_EXTIF
        char           *callback_report;
#endif

        work_module_item = dl_list_head (instantiated_modules);
        tm_get_module_filename (temp_module_item, name);

        /* first we will search for module that was the source for "temp", 
	 * using filename */
        while (work_module_item != DLListNULLIterator) {
                tm_get_module_filename (work_module_item, name2);
                it = strcmp (name, name2);

                if (it == 0) {
                        tc_get_cfg_filename (work_case_item, work_conf);
                        orig_case =
                            dl_list_head (tm_get_tclist (work_module_item));
                        if (orig_case == DLListNULLIterator)
                                break;
                        while (orig_case != DLListNULLIterator) {
                                tc_get_cfg_filename (orig_case, orig_conf);
                                if (strstr (work_conf, orig_conf) != NULL) {
                                        cont_flag = 0;
                                        break;
                                } else
                                        orig_case = dl_list_next (orig_case);
                        }
                }

                if (cont_flag == 1)
                        work_module_item = dl_list_next (work_module_item);
                else
                        break;
        }

        if (work_module_item == DLListNULLIterator) {
                MIN_WARN ("MODULE Data fault");
                return -1;
        }

        /*now we will search for original test case, using id and config
	  filename */
        id = tc_get_id (work_case_item);
        tc_get_cfg_filename (work_case_item, work_conf);
        orig_case = dl_list_head (tm_get_tclist (work_module_item));

        while (orig_case != DLListNULLIterator) {
                tc_get_cfg_filename (orig_case, orig_conf);
                id2 = tc_get_id (orig_case);
                if ((id == id2) && (strcmp (work_conf, orig_conf) == 0))
                        break;
                else
                        orig_case = dl_list_next (orig_case);
        }

        if (orig_case == DLListNULLIterator) {
                MIN_WARN ("CASE Data fault");
                return -1;
        }

        work_result = tr_create_data_item (orig_case);
        work_result_item = tr_add (tc_get_tr_list (orig_case), work_result);
        /* since module was started to run just one case once, it will have
	 * only one test result, from which we will now copy data to 
	 * original test case 
	 */
        temp_result = dl_list_head (tc_get_tr_list (work_case_item));   
        tr_set_result_description (work_result_item, message->message_);
        tr_set_start_time (work_result_item, tr_get_start_time (temp_result));
        tr_set_result_description (work_result_item, message->message_);
        tr_set_end_time (work_result_item, time (NULL));

        switch (message->param_) {
        case TP_CRASHED:

                tr_set_result_type (work_result_item, TEST_RESULT_CRASHED);
                break;

        case TP_TIMEOUTED:

                tr_set_result_type (work_result_item, TEST_RESULT_TIMEOUT);
                break;

        case TP_PASSED:

                tr_set_result_type (work_result_item, TEST_RESULT_PASSED);
                break;

        case TP_FAILED:

                tr_set_result_type (work_result_item, TEST_RESULT_FAILED);
                break;

        case TP_NC:

                tr_set_result_type (work_result_item, TEST_RESULT_NOT_RUN);
                break;

        case TP_LEAVE:

                tr_set_result_type (work_result_item, TEST_RESULT_FAILED);
                break;

        default:

                MIN_WARN ("Faulty data received");
                return (-1);

        }

        tr_set_priontouts_list (work_result_item,
                                tr_get_priontouts_list (temp_result));
        ((test_result_s *) dl_list_data (temp_result))->printouts_list_ =
            INITPTR;

        /*now add result to global "results" list */
        /*dl_list_add(dl_list_data(work_result_item),results); */
        /*result data was copied. Now we need to find case from temp module in
           "selected cases" */


        pthread_mutex_lock (&tec_mutex_);

        work_case_item = dl_list_head (selected_cases);
        orig_case_no = 0;
        while (work_case_item != DLListNULLIterator) {
                if (tc_get_test_module_ptr (work_case_item) ==
                    temp_module_item)
                        break;
                orig_case_no++;
                work_case_item = dl_list_next (work_case_item);
        }
        pthread_mutex_unlock (&tec_mutex_);

        if (work_case_item == DLListNULLIterator) {
                MIN_WARN ("could not find case in list");
                return -1;
        }
        work_module_item =
            tm_get_ptr_by_pid (instantiated_modules, message->sender_);
        tc_set_status (work_case_item, TEST_CASE_TERMINATED);
        pthread_mutex_lock (&tec_mutex_);
        pthread_mutex_unlock (&tec_mutex_);

#ifndef MIN_EXTIF
#ifndef MIN_UNIT_TEST
        cui_refresh_view ();
#endif
#endif
#ifdef MIN_EXTIF
        callback_report = NEW2 (char, strlen (message->desc_) + 1);
        sprintf (callback_report, "%s", message->desc_);
        extif_callbacks.complete_callback_ (orig_case_no, 1, message->param_,
                                            callback_report);
#endif
        ec_remove_module_temp (work_module_item);
        ec_check_next_in_group (group_id);
        result = 1;

        return result;
}



/**Function handling MSG_OK. As it is first message sent by module, 
 * function set's module status to TC_SENDING, initilaizes test cases list
 * for module and sends message MSG_GTC
 * @param message pointer to MsgBuffer structure containing message
 * @return result of message handling, 0 if message handling was succesful, 
 *         -1 otherwise
 */
LOCAL int ec_msg_ok_handler (MsgBuffer * message)
{
        int             result = -1;
        long            sender = message->sender_;
        int             work_module_status;
        DLListIterator  work_module =
            tm_get_ptr_by_pid (instantiated_modules, sender);
        MsgBuffer       message_gtc;

        /*Possible error handling will be inserted here */

        if (work_module == DLListNULLIterator) {

                MIN_WARN ("Could not fetch module data, pid = %d", sender);
                work_module = dl_list_head (instantiated_modules);

                while (work_module != DLListNULLIterator) {
                        work_module = dl_list_next (work_module);
                }
                return result;
        }

        work_module_status = tm_get_status (work_module);

        switch (work_module_status) {
        case TEST_MODULE_INITIALIZED:
                tm_set_status (work_module, TEST_MODULE_TC_SENDING);
                result = 0;
                message_gtc.type_ = MSG_GTC;
                message_gtc.sender_ = ec_settings.engine_pid_;
                message_gtc.receiver_ = message->sender_;
                message_gtc.param_ = 0;
                message_gtc.special_ = ESTrue;  /*TCDs should be sent */
                mq_send_message (mq_id, &message_gtc);
                break;

        case TEST_MODULE_INITIALIZED_TEMP:

                result = 0;
                message_gtc.type_ = MSG_GTC;
                message_gtc.sender_ = ec_settings.engine_pid_;
                message_gtc.receiver_ = message->sender_;
                message_gtc.param_ = 0;
                message_gtc.special_ = ESFalse; /*don't care about 
                                                   TCDs */
                mq_send_message (mq_id, &message_gtc);
                break;

        default:

                MIN_WARN ("Unexpected message sequence");
                result = -1;
                break;

        }

#ifdef MIN_UNIT_TEST
        unit_test_result = result;
#endif                          /*MIN_UNIT_TEST */

        return result;
}


/**Function handling MSG_KO message, which means that some trouble occured on
 * tmc's side. Hadling depends on state of module: if it's 
 * TEST_MODULE_INITIALIZED, it means that test case extraction is impossible.
 * Module will be removed from "instantiated" list and terminated.Problems 
 * will be logged.
 * @param message - pointer to MsgBuffer containing message
 */
LOCAL int ec_msg_ko_handler (MsgBuffer * message)
{
        int             result = -1;
        int             status = 0;
        DLListIterator  work_module_item = DLListNULLIterator;
        /*work module fetched from list of instantiated modules */

        work_module_item =
            tm_get_ptr_by_pid (instantiated_modules, message->sender_);

        if (work_module_item == DLListNULLIterator) {

                MIN_WARN ("Could not fetch module data");
                return result;
        }

        status = tm_get_status (work_module_item);
        switch (status) {
        case TEST_MODULE_INITIALIZED:
                mq_send_message2 (mq_id, message->sender_, MSG_END, 0,
                                  "Useless module");
                waitpid (message->sender_, NULL, 0);
                dl_list_remove_it (work_module_item);
                MIN_WARN ("Could not fetch test cases");
                result = 0;
                break;

        default:

                result = -1;
                MIN_WARN ("Unexpected message sequence");
                break;

        }

        return result;
}


/**Function handling MSG_RET with test case results
 * @param message - pointer to MsgBuffer containing message
 */
LOCAL int ec_msg_ret_handler (MsgBuffer * message)
{

        DLListIterator  work_case_item = INITPTR;
        DLListIterator  dest_case_item = INITPTR;
        DLListIterator  work_module_item = INITPTR;
        test_case_s    *work_case = INITPTR;
        DLList         *work_result_list = INITPTR;
        DLListIterator  work_result_item = INITPTR;
        int             group_id;
#ifdef MIN_EXTIF
        char           *callback_report;
#endif
        int             orig_case_no;
        filename_t      orig_conf;
        filename_t      work_conf;
        test_result_s  *result;
	int		fun_result = 0;
        const char     *test_result_type_str[] = {
                "not run",
                "passed",
                "failed",
                "crashed",
                "aborted",
                "timeout",
                "all"
        };

        work_module_item =
            tm_get_ptr_by_pid (instantiated_modules, message->sender_);
        if (work_module_item == DLListNULLIterator) {

                MIN_WARN ("Failed to fetch module data");
		fun_result = -1;
		goto EXIT;
        }
        /* if module was instantiated as temporary, handling is different 
	 * since it was created only to run one test case
	 */
        if (tm_get_status (work_module_item) == TEST_MODULE_BUSY_TEMP) {
                ec_handle_temp_results (work_module_item, message);
		fun_result = 1;
		goto EXIT;
        }
        /* in current design, there is only one test case with status : ongoing
	 * belonging to module with given PID, so we search "selected cases" 
	 * list for test case based on that information
	 */
        pthread_mutex_lock (&tec_mutex_);


        work_case_item = dl_list_head (selected_cases);
        orig_case_no = 0;
        while (work_case_item != DLListNULLIterator) {

                work_case = (test_case_s *) dl_list_data (work_case_item);
                if (((tc_get_status (work_case_item)) == TEST_CASE_ONGOING) &&
                    ((tm_get_pid (tc_get_test_module_ptr (work_case_item))) ==
                     message->sender_))
                        /* we found ongoing case with module matching message 
			 * sender's pid, co we can stop
			 * iterating through list 
			 */
                        break;
                orig_case_no++;
                work_case_item = dl_list_next (work_case_item);

        }

        pthread_mutex_unlock (&tec_mutex_);

        if (work_case_item == DLListNULLIterator) {
		fun_result = -1;
		goto EXIT;
	}


        work_result_list = tc_get_tr_list (work_case_item);
        if (work_result_list == INITPTR) {
                MIN_WARN ("Fault in test data");
		fun_result = -1;
		goto EXIT;
        }

        work_result_item = dl_list_head (work_result_list);
        tr_set_result_description (work_result_item, message->message_);
        tr_set_end_time (work_result_item, time (NULL));

        switch (message->param_) {

        case TP_CRASHED:

                tr_set_result_type (work_result_item, TEST_RESULT_CRASHED);
                break;

        case TP_TIMEOUTED:

                tr_set_result_type (work_result_item, TEST_RESULT_TIMEOUT);
                break;

        case TP_PASSED:

                tr_set_result_type (work_result_item, TEST_RESULT_PASSED);
                break;

        case TP_FAILED:

                tr_set_result_type (work_result_item, TEST_RESULT_FAILED);
                break;

        case TP_NC:

                tr_set_result_type (work_result_item, TEST_RESULT_ABORTED);
                break;

        case TP_LEAVE:

                tr_set_result_type (work_result_item, TEST_RESULT_FAILED);
                break;

        default:

                MIN_WARN ("Faulty data received");
		fun_result = -1;
		goto EXIT;
        }
        MIN_DEBUG ("RESULT CODE = %s (%d)",
                    test_result_type_str [tr_get_result_type
                                          (work_result_item)],
                    tr_get_result_type (work_result_item));
        tm_set_status (work_module_item, TEST_MODULE_READY);
        tc_set_status (work_case_item, TEST_CASE_TERMINATED);
        group_id = tc_get_group_id (work_case_item);

        /* Now let's link created result item to original test case. 
	 * We will use module link, test case id and test case filename 
	 */
        dest_case_item = dl_list_head (tm_get_tclist (work_module_item));
        tc_get_cfg_filename (work_case_item, work_conf);


        while (dest_case_item != DLListNULLIterator) {
                tc_get_cfg_filename (dest_case_item, orig_conf);
                if ((tc_get_id (dest_case_item) == tc_get_id (work_case_item))
                    && (strcmp (work_conf, orig_conf) == 0)) {
                        break;
                }
                dest_case_item = dl_list_next (dest_case_item);
        }
        result = NEW (test_result_s);
        memcpy (result,
                dl_list_data (work_result_item), sizeof (test_result_s));
        ((test_result_s *) dl_list_data (work_result_item))->printouts_list_ =
            INITPTR;
        work_result_item = tr_add (tc_get_tr_list (dest_case_item), result);

        ((test_result_s *) dl_list_data (work_result_item))->tc_data_item_ =
            dest_case_item;
        /*now add result to global "results" list */
        /*dl_list_add(dl_list_data(work_result_item),results); */

        MIN_DEBUG ("orig_case has %d results now",
                    dl_list_size (tc_get_tr_list (dest_case_item)));
        work_result_item = dl_list_head (tc_get_tr_list (dest_case_item));
        while (work_result_item != DLListNULLIterator) {
                MIN_DEBUG ("RESULT CODE = %s (%d)",
                             test_result_type_str
                             [tr_get_result_type (work_result_item)],
                             tr_get_result_type (work_result_item));

                work_result_item = dl_list_next (work_result_item);
        }


        if (group_id != 0)
                ec_check_next_in_group (group_id);
#ifndef MIN_EXTIF
#ifndef MIN_UNIT_TEST
        cui_refresh_view ();
#endif
#endif
#ifdef MIN_EXTIF
        callback_report = NEW2 (char, strlen (message->desc_) + 1);
        sprintf (callback_report, "%s", message->desc_);
        extif_callbacks.complete_callback_ (orig_case_no, 1, message->param_,
                                            callback_report);
        DELETE (callback_report);
#endif
EXIT:
        return fun_result;
}


/** Function handling MSG_TCD message. It creates new test_case_s structure and
 * inserts it into
 * apropriate module's case list.
 * @param message - pointer to MsgBuffer containing message
 * @return result of message handling, 0 if message was handled, -1 otherwise
 */
LOCAL int ec_msg_tcd_handler (MsgBuffer * message)
{
        int             result = -1;
        int             work_module_status = 0;
        int             address = 0;
        DLListIterator  work_module_item = DLListNULLIterator;
        DLListIterator  work_case_item = DLListNULLIterator;
        test_case_s    *work_case = INITPTR;
        DLList         *work_tclist = INITPTR;

        work_module_item =
            tm_get_ptr_by_pid (instantiated_modules, message->sender_);
        if (work_module_item == DLListNULLIterator)
		goto EXIT;

        work_module_status = tm_get_status (work_module_item);

        work_tclist = tm_get_tclist (work_module_item);
        if (work_tclist == INITPTR)
		goto EXIT;

        if (message->param_ == 0) {

                switch (work_module_status) {
                case TEST_MODULE_TC_SENDING:
                        MIN_DEBUG ("finished tc gathering");
                        if (dl_list_size (tm_get_tclist (work_module_item)) ==
                            0) {
                                /* something went wrong, module has 0 tcs, 
				 * and can be removed - at least in current 
				 * design 
				 */
                                address = tm_get_pid (work_module_item);
                                mq_send_message2 (mq_id, address, MSG_END, 0,
                                                  "Shut down !");
                                waitpid (address, NULL, 0);
                                tm_remove (work_module_item);
				result = 0;
				goto EXIT;
                                break;
                        } else {
                                tm_set_status (work_module_item,
                                               TEST_MODULE_READY);
                                result = 0;
				goto EXIT;
                        }
                        break;
                case TEST_MODULE_INITIALIZED_TEMP:
                        tm_set_status (work_module_item,
                                       TEST_MODULE_BUSY_TEMP);
                        /* first case from list will be fetched and executed,
			 * since temp module has only one case in list 
			 */
                        result = ec_exec_case_temp (work_module_item);
                        goto EXIT;
                        break;
                default:
                        MIN_WARN (" UNEXPECTED MESSAGE SEQUENCE ");
                        result = -1;
			goto EXIT;
                        break;
                }
        }

        if (work_module_status == TEST_MODULE_TC_SENDING) {
                work_case =
                    tc_create (work_module_item, message->desc_,
                               message->message_);
                work_case_item = tc_add (work_tclist, work_case);
                tc_set_id (work_case_item, message->param_);
                if (in.new_case) {
                        in.new_case (tm_get_module_id (work_module_item),
                                     work_case->tc_id_,
                                     work_case->title_);
                }
        }
        result = 0;
EXIT:
	return result;
}


/** Function handling MSG_EVENT message.
 * @param message - pointer to MsgBuffer containing message
 * @return result of message handling, 0 if message was handled, -1 otherwise
 */
LOCAL int ec_msg_event_handler (MsgBuffer * message)
{
        minTestEventParam_t param;
        minEventSrc_t  esrc;
	int result = 0;
#ifdef MIN_EXTIF
        int             status;
#endif

        if (!event_system_up ()) {
                MIN_WARN ("Event System is not initialized, can not handle "
                           "message");
		result = -1;
		goto EXIT;
        }
        param.event.event_type_ = (message->param_ >> 8) & 0xff;
        param.command_ = message->param_ & 0xff;

        param.event.event_name_ = NEW2 (char, strlen (message->message_) + 1);

        STRCPY (param.event.event_name_, message->message_,
                strlen (message->message_) + 1);

        esrc.remote = 0;
        esrc.pid = message->special_;
        switch (param.event.event_type_) {
        case EIndication:
                switch (param.command_) {
                case EReqEvent:
                        MIN_DEBUG ("Indication Event: REQUEST");
                        ind_event_handle_request (&param, &esrc);
                        break;
                case EWaitEvent:
                        MIN_DEBUG ("Indication Event: WAIT");
                        ind_event_handle_wait (&param, &esrc
#ifdef MIN_EXTIF
                                               , &status
#endif
                            );
                        break;
                case ERelEvent:
                        MIN_DEBUG ("Indication Event: RELEASE");
                        ind_event_handle_release (&param, &esrc);
                        break;
                case ESetEvent:
                        MIN_DEBUG ("Indication Event: SET");
                        ind_event_handle_set (&param, &esrc);
                        break;
                case EUnsetEvent:
                        MIN_DEBUG ("Indication Event: UNSET N/A for"
                                     " Indications");
                        break;
                default:
                        break;
                }
                break;
        case EState:
                switch (param.command_) {
                case EReqEvent:
                        MIN_DEBUG ("State Event: REQUEST");
                        state_event_handle_request (&param, &esrc);
                        break;
                case EWaitEvent:
                        MIN_DEBUG ("State Event: WAIT");
                        state_event_handle_wait (&param, &esrc
#ifdef MIN_EXTIF
                                                 , &status
#endif
                            );
                        break;
                case ERelEvent:
                        MIN_DEBUG ("State Event: RELEASE");
                        state_event_handle_release (&param, &esrc);
                        break;
                case ESetEvent:
                        MIN_DEBUG ("State Event: SET");
                        state_event_handle_set (&param, &esrc);
                        break;
                case EUnsetEvent:
                        MIN_DEBUG ("State Event: UNSET");
                        state_event_handle_unset (&param, &esrc);
                        break;
                default:
                        break;
                }
                break;
        default:
                MIN_WARN ("Unsupported event type %d\n",
                           param.event.event_type_);
                break;
        }

        DELETE (param.event.event_name_);
EXIT:
        return result;
}


/** Function handling MSG_USR message. this message is used to pass 
 * "printouts" from test case to console UI. Handler will write received 
 * data to apropriate place in test result's printouts list according to 
 * priority of printout. Accessing proper
 * test case/result data will be done in a way similar to MSG_RET handler.
 * @param message pointer to MsgBuffer containing read message
 * @return result of message handling, 0 if message was handled, -1 otherwise.
 */
LOCAL int ec_msg_usr_handler (MsgBuffer * message)
{

        DLListIterator  work_module_item = INITPTR;
        DLListIterator  work_case_item = INITPTR;
        DLListIterator  work_printout_item = INITPTR;
        test_case_s    *work_case = INITPTR;
        DLListIterator  work_result_item = INITPTR;
        DLList         *work_list = INITPTR;
        test_result_printout_s *print_msg;
        unsigned int    it = 0; /*general purpose iterator */
        int             case_id;
	int 		result = 0;

        work_module_item =
            tm_get_ptr_by_pid (instantiated_modules, message->sender_);
        print_msg = tr_create_printout (message->param_, message->message_);

        if (work_module_item == DLListNULLIterator) {
                MIN_WARN ("Failed to fetch module data");
		result = -1;
		goto EXIT;
        }

       /* in current design, there is only one test case with status : 
	* ongoing belonging to module with given PID, so we search 
	* "selected cases" list for test case based on that
	* information
	*/
        pthread_mutex_lock (&tec_mutex_);

        case_id = 0;
        work_case_item = dl_list_head (selected_cases);
        while (work_case_item != DLListNULLIterator) {

                work_case = (test_case_s *) dl_list_data (work_case_item);

                if (((tc_get_status (work_case_item)) == TEST_CASE_ONGOING) &&
                    ((tm_get_pid (tc_get_test_module_ptr (work_case_item))) ==
                     message->sender_))
                        /* we found ongoing case with module matching message
			 * sender's pid, co we can stop iterating through list
			 */
                        break;
                case_id++;
                work_case_item = dl_list_next (work_case_item);

        }

        pthread_mutex_unlock (&tec_mutex_);

        if (work_case_item == DLListNULLIterator){
		result = -1;
		goto EXIT;
	}

        work_list = tc_get_tr_list (work_case_item);
        if (work_list == INITPTR) {
                MIN_WARN ("Fault in test data");
		result = -1;
		goto EXIT;
        }

        work_result_item = dl_list_head (work_list);
        while (work_result_item != DLListNULLIterator) {
                if (tr_get_result_type (work_result_item) ==
                    TEST_RESULT_NOT_RUN)
                        break;
                work_result_item = dl_list_next (work_result_item);
        }

        work_list = tr_get_priontouts_list (work_result_item);
        work_printout_item = dl_list_head (work_list);
        while (work_printout_item != DLListNULLIterator) {
                if (((test_result_printout_s *)
                     dl_list_data (work_printout_item))->priority_ >
                    message->param_)
                        break;
                it++;
                work_printout_item = dl_list_next (work_printout_item);
        }
        //dl_list_add_at (work_list, ( void* ) print_msg, it);
        dl_list_add (work_list, (void *)print_msg);
#ifndef MIN_EXTIF
#ifndef MIN_UNIT_TEST
        cui_refresh_view ();
#endif
#endif
#ifdef MIN_EXTIF
        extif_callbacks.print_callback_ (case_id, message->message_);
#endif
EXIT:
        return result;
}

/** Function called to dispatch message - it recognizes message type and
 * calls function that handles message. If received message is not of the type
 * expected by engine, function logs error information.
 * @param message - pointer to received MsgBuffer
 * @return result of message handling, 0 if message was handled, -1 otherwise.
*/
LOCAL int ec_message_dispatch (MsgBuffer * rcvd_message)
{
        int             msg_handling_result = -1;

        MIN_DEBUG ("MsgBuffer::message = %s", rcvd_message->message_);
        MIN_DEBUG ("MsgBuffer::desc = %s", rcvd_message->desc_);
        MIN_DEBUG ("MsgBuffer::type = %d", rcvd_message->type_);
        switch (rcvd_message->type_) {
        case MSG_OK:

                msg_handling_result = ec_msg_ok_handler (rcvd_message);
                break;

        case MSG_USR:

                msg_handling_result = ec_msg_usr_handler (rcvd_message);
                break;

        case MSG_RET:

                msg_handling_result = ec_msg_ret_handler (rcvd_message);
                break;

        case MSG_KO:

                msg_handling_result = ec_msg_ko_handler (rcvd_message);
                break;

        case MSG_TCD:

                msg_handling_result = ec_msg_tcd_handler (rcvd_message);
                break;

        case MSG_EVENT:

                msg_handling_result = ec_msg_event_handler (rcvd_message);
                break;
#ifdef  MIN_EXTIF
        case MSG_EXTIF:
                msg_handling_result = ec_msg_ms_handler (rcvd_message);
                break;
        case MSG_SNDRCV:
                msg_handling_result = ec_msg_sndrcv_handler (rcvd_message);
                break;
#endif
        default:

                MIN_WARN ("Faulty message received of type: %d",rcvd_message->type_);
        }

        return msg_handling_result;

}


/** Function that is the basis for message listening thread. Contains while 
 * loop that checks messages in queue and calls ec_msg_dispatch to handle any
 * message
 * @param arg some dummy pointer, to keep compiler from complaining
 */
LOCAL void     *ec_message_listener (void *arg)
{

        int             handling_result = 0;
        long            own_address = 0;
        unsigned long   wait_time = 2;  /*time in miliseconds that thread 
                                           spends sleeping during periods
                                           with no IPC traffic */
        MsgBuffer       received_msg;

        pthread_mutex_lock (&tec_mutex_);
        /* Engine's process id was made global, because passing it to message
	 * listener function as a pointer has proven to be unreliable, 
	 * especially on ARM targets. 
	 */
        own_address = ec_settings.engine_pid_;  
        pthread_mutex_unlock (&tec_mutex_);

#ifdef MIN_UNIT_TEST
        unit_test_result = 1;
#endif                          /*MIN_UNIT_TEST */
        while (1) {
                handling_result = mq_peek_message (mq_id, own_address);
                if (handling_result != 0) {
                        wait_time = 2;
                        handling_result =
                            mq_read_message (mq_id, own_address,
                                             &received_msg);
                        if (handling_result > 8) {
                                ec_message_dispatch (&received_msg);
                        } else {
                                MIN_WARN ("Message_handling_fault");
                        }
                } else {
                        if (errno == EINVAL) {
                                MIN_INFO ("Message queue was destroyed,"
                                            " exiting listener thread");
                                pthread_exit (NULL);
                        } else {

                                if (wait_time < 200000)
                                        wait_time = wait_time * 10;
                                /*sleep should not be longer than 0.2 sec. */
                                usleep (wait_time);
                        }
                }



#ifdef MIN_UNIT_TEST
                unit_test_result = handling_result;
#endif
        }

        return NULL;
}

/*-----------------------------------------------------------------------*/
/** Function that wraps test module controller process starting. In case of 
* failure to start a module, information will be logged.
* @param work_module_item item from available modules list
* @return pid of newly created process, or -1 in case of failure*/

LOCAL pid_t ec_start_tmc (DLListIterator work_module_item)
{
        char          **exec_args = NULL;

        DLListIterator  work_file_item;
        char           *mod_fpath = NULL;
        char           *mod_fpath_new = NULL;
        char           *dir = NULL;
        char           *mod_name = NULL;
        char           *conf_name = NULL;
        char           *conf_path = NULL;

        int             it = 0; /*general purpose loop iterator */
        /*position of directory in search paths list */
        int             path_pos = 0;   
        int             result = -1;
        int             retval = -1;
        pid_t           res_pid = 0;

        DLList         *work_list;

        work_list  = tm_get_cfg_filenames (work_module_item);
        exec_args = NEW2 (char *, dl_list_size (work_list) + 3);
        exec_args[it++] = ec_settings.tmc_app_path_;

        if (*((test_module_info_s *) dl_list_data (work_module_item))->
            module_filename_ == '/') {
                mod_fpath =
                    ((test_module_info_s *) dl_list_data (work_module_item))->
                    module_filename_;
                result = access (mod_fpath, F_OK);
                if (result != 0) {
                        MIN_WARN ("Module not found");
                        retval = -1;
                        goto out;
                }
        } else {
                mod_name =
                    NEW2 (char,
                          strlen (((test_module_info_s *)
                                   dl_list_data (work_module_item))->
                                  module_filename_) + 4);
                sprintf (mod_name, "%s.so",
                         ((test_module_info_s *)
                          dl_list_data (work_module_item))->module_filename_);
                path_pos = ec_search_lib (mod_name);

                if (path_pos != -1) {
                        dir =
                            (char *)
                            dl_list_data (dl_list_at
                                          (ec_settings.search_dirs,
                                           path_pos));
                        mod_fpath_new =
                            NEW2 (char, strlen (dir) + strlen (mod_name) + 2);
                        mod_fpath = mod_fpath_new;
                        sprintf (mod_fpath, "%s/%s", dir, mod_name);
                }
        }

        if (mod_fpath == NULL) {
                MIN_WARN ("Module not found");
                retval = -1;
                goto out;
        }
        exec_args[it++] = mod_fpath;
        work_file_item = dl_list_head (work_list);
        while (work_file_item != DLListNULLIterator) {
                conf_name = (char *)dl_list_data (work_file_item);
                work_file_item = dl_list_next (work_file_item);
                if (*conf_name == '/') {
                        /*config file was defined as full path */
                        conf_path = NEW2 (char, strlen (conf_name) + 1);
                        sprintf (conf_path, "%s", conf_name);
                        exec_args[it++] = conf_path;
                        continue;
                }

                conf_path = NEW2 (char, strlen (conf_name) +
                                  strlen ((char *)
                                          dl_list_data (dl_list_at
                                                        (ec_settings.
                                                         search_dirs,
                                                         path_pos))) + 2);
                sprintf (conf_path, "%s/%s",
                         (char *)
                         dl_list_data (dl_list_at
                                       (ec_settings.search_dirs, path_pos)),
                         conf_name);
                /* now check if config exists in the same directory as 
                   module */
                result = access (conf_path, F_OK);
                if (result == 0) {
                        exec_args[it++] = conf_path;
                        continue;
                }
                /*config not found so far, let's look for it in search
                   paths */
                path_pos = ec_search_lib (conf_name);
                if (path_pos != -1) {
                        dir =
                            (char *)
                            dl_list_data (dl_list_at
                                          (ec_settings.search_dirs,
                                           path_pos));
                        if (conf_path)
                                DELETE (conf_path);
                        conf_path =
                            NEW2 (char,
                                  strlen (dir) + strlen (conf_name) + 2);
                        sprintf (conf_path, "%s/%s", dir, conf_name);
                        exec_args[it++] = conf_path;
                        continue;
                }
                MIN_WARN ("specified config not found : %s", conf_name);
                retval = -1;
                goto out;

        }
        exec_args[it++] = NULL;
        res_pid = fork ();
        switch (res_pid) {
        case -1:
                MIN_FATAL ("Failed to create process !");
                break;
        case 0:
                sched_yield ();
                execve (exec_args[0], exec_args, envp);
                MIN_FATAL ("Failed to load test module controller app :%s",
                             strerror (errno));
                exit (0);
                break;
        default:
                break;
        };
        tm_set_pid (work_module_item, res_pid);
        retval = res_pid;
      out:
        DELETE (exec_args);
        DELETE (mod_fpath_new);
        DELETE (mod_name);
        DELETE (conf_path);
        return retval;
}


/** Function that initializes data for instantiated module
 * @param work_module_item list item with module
 * @param proc_id PID of associated TMC process
 * @return always 0
 */
LOCAL int ec_init_module_data (DLListItem * work_module_item)
{

        int             result = 0;
        DLList         *cases_list;

        tm_set_status (work_module_item, TEST_MODULE_INITIALIZED);
        cases_list = dl_list_create ();
        tm_set_tclist (work_module_item, cases_list);

        return result;
}

/** Function that instantializes all modules from available moduls list at
* startup of the application.
* @return: 0 if operation succeeded, -1 in case failure. Inability to start one
* module is not a failure. */
int ec_start_modules ()
{

        int             result = 0;
        pid_t           module_started = 0;
        test_module_info_s *work_module;
        DLListIterator  work_list_item = dl_list_head (available_modules);
        DLListIterator  result_list_item;
        int             opresult = 0;
        
        MIN_DEBUG ("%d available modules",
                     dl_list_size (available_modules));

        work_module = (test_module_info_s *) dl_list_data (work_list_item);
        while (work_list_item != DLListNULLIterator) {
                module_started = ec_start_tmc (work_list_item);

                if (module_started > 0) {
                        result_list_item =
                            tm_add (instantiated_modules, work_module);
                        opresult = ec_init_module_data (result_list_item);
                        if (opresult < 0)
                                MIN_WARN ("Failed to initialize "
                                           "data for module");
                        /* To be decided if additional handling of that 
			 * fault is needed 
			 */
                }

                else {
                        result++;
                }
                work_list_item = dl_list_next (work_list_item);

                if (work_list_item != DLListNULLIterator) {
                        work_module = dl_list_data (work_list_item);
                }
        }

        return result;
}

LOCAL int ec_read_module_section (MinParser * inifile)
{
        test_module_info_s      *module         = INITPTR;
        DLListIterator          module_item = DLListNULLIterator;
        MinSectionParser       *module_def = INITPTR;
        MinItemParser          *line_item; 
        char           *bin_path = INITPTR, *tc_file_path = NULL;
        int            it = 1;
        DLList         *work_list;


        module_def = mp_section (inifile, "[New_Module]", "[End_Module]", it);

        while (module_def != INITPTR) {


                line_item = mmp_get_item_line(module_def,
                                             "ModuleName",
                                             ESTag);

                if (line_item == INITPTR){
                        MIN_WARN ("Data fault!");
                        break;
                }

                mip_get_string(line_item,
                              "ModuleName",
                              &bin_path);


                if (bin_path == INITPTR) {
                        MIN_WARN ("Could not read module definition");
                        break;
                }
                /* make dummy list of cfgs for now */

                work_list = dl_list_create ();
                module = tm_create (bin_path, work_list, 0);
                module_item = tm_add (available_modules, module);
                if (in.new_module) {
                        in.new_module (bin_path, module->module_id_);
                }

                if (module_item == DLListNULLIterator) {
                        MIN_WARN ("Could not insert %s into list",
                                   bin_path);
                        break;
                }

                /* Now let's read test case files, tag : TestCaseFile= */
                do {
                        DELETE (bin_path);
                        mip_destroy(&line_item);

                        line_item = mmp_get_next_item_line(module_def);

                        mip_get_string(line_item,
                                      "TestCaseFile",
                                      &bin_path);



                        if (bin_path != INITPTR) {
                                tc_file_path = NEW2 (char,
                                                     strlen (bin_path) + 2);
                                STRCPY (tc_file_path, bin_path,
                                        strlen (bin_path) + 1);
                                dl_list_add (work_list, (void *)tc_file_path);
                        }

                } while (bin_path != INITPTR);;

                mmp_destroy (&module_def);
                it++;

                module_def = mp_section (inifile,
                                         "[New_Module]", "[End_Module]", it);

        }
        return 0;
}

LOCAL int ec_read_module_confdir ()
{

        DIR            *dir;
        struct dirent  *dirent;
        MinParser     *modfile = INITPTR;

        dir = opendir ("/etc/min.d");

        if (dir == NULL) {
                MIN_WARN ("directory /etc/min.d missing");
                return 1;
        }

        dirent = readdir (dir);
        while (dirent != NULL) {
                if (dirent->d_type == DT_LNK || dirent->d_type == DT_REG) {
                        modfile = mp_create ("/etc/min.d/",
                                             dirent->d_name, ENoComments);
                        ec_read_module_section (modfile);

                }
                dirent = readdir (dir);
        }

        closedir (dir);

        return 0;
}

/** Function reads data from config file given as argument
 */
LOCAL int ec_read_conf (MinParser * inifile, int operation_mode)
{
        MinSectionParser *engine_def = INITPTR;
        MinSectionParser *logger_def = INITPTR;
        MinItemParser    *line_item  = INITPTR;
        struct  stat    tmcstat;   
        char           *search_path = INITPTR;
        char           *path_string = NULL;
        char           *bin_path = INITPTR;
        char           *locdir = NULL;
        char           *home_d = getenv ("HOME");
        /*int res = 0;for checking funtion return values */

        /*read engine's settings */
        engine_def = mp_section (inifile,
                                 "[Engine_Defaults]", "[End_Defaults]", 1);

        if (engine_def == INITPTR) {
                MIN_FATAL ("For information about mandatory min.conf"
			     " contents refer to manual");
        }


        line_item = mmp_get_item_line(engine_def,
                                      "TmcBinPath",
                                      ESTag);

        mip_get_string(line_item,
                       "TmcBinPath",
                       &bin_path);


        if (bin_path == INITPTR) {
                bin_path = NEW2(char, 
                                strlen(MIN_BIN_DIR) + strlen("/tmc") + 1 );
                sprintf (bin_path, "%s/tmc", MIN_BIN_DIR);
        }
        
        /*
        ** Check if tmc lies in the specified place
        */
        memset (&tmcstat, 0, sizeof (struct stat));
        if (stat (bin_path, &tmcstat)) {
                MIN_FATAL ("TMC binary not available: %s. Exiting..\n",
                            strerror (errno));
                goto err_exit;
        }
        if (!(tmcstat.st_mode & S_IXUSR &&
              tmcstat.st_mode & S_IXGRP &&
              tmcstat.st_mode & S_IXOTH)) {
                MIN_FATAL ("TMC binary %s does not have execution permission."
                            "Exiting..\n", bin_path);
                goto err_exit;

        }
        STRCPY (ec_settings.tmc_app_path_, bin_path, MaxFileName);


        if (line_item != INITPTR) mip_destroy(&line_item);

        line_item = mmp_get_item_line(engine_def,
                                      "ModSearchPath",
                                      ESTag);

        mip_get_string(line_item,
                       "ModSearchPath",
                       &search_path);

        while (search_path != INITPTR) {
                if (strstr (search_path, "$HOME") == NULL) {
                        path_string = NEW2 (char, strlen (search_path) + 1);
                        sprintf (path_string, "%s", search_path);
                        dl_list_add (ec_settings.search_dirs,
                                     (void *)path_string);
                } else {
                        if (home_d == NULL) {
                                MIN_WARN ("$HOME == NULL, not adding "
                                           "%s to engine settings", 
                                           search_path);
                                goto next_item;
                        }
                        locdir = strchr (search_path, '/');
                        if (locdir != NULL) {
                                path_string =
                                        NEW2 (char,
                                              strlen (locdir) 
                                              + strlen (home_d) +
                                              1);
                                sprintf (path_string, "%s%s", home_d, locdir);
                                dl_list_add (ec_settings.search_dirs,
                                             (void *)path_string);
                        } else {
                                MIN_WARN ("Invalid path");
                        }
                }
        next_item:
                mip_destroy(&line_item);
                line_item = mmp_get_next_item_line(engine_def);
                DELETE(search_path);
                mip_get_string(line_item,
                               "ModSearchPath",
                               &search_path);
                
                
        }
        if (bin_path != INITPTR) {
                DELETE (bin_path);
        }
        mmp_destroy (&engine_def);
        /* check if logger settings are present and read them */
        logger_def = mp_section (inifile,
                                 "[Logger_Defaults]",
                                 "[End_Logger_Defaults]", 1);

        if (logger_def != INITPTR) {
                ec_get_logger_settings (logger_def);
                mmp_destroy (&logger_def);
        }
        if (operation_mode == 0) {
                /*we should read module definitions only
                   if we don't use external controller */
                ec_read_module_section (inifile);
        }

        return 0;
err_exit:
        ec_cleanup();
        exit (1);
        
        return -1;
}

/** Function reads config files in following order : MIN_CONF_DIR/min.conf, 
 * $HOME/.min/min.conf, ./min.conf. Settings with single value are 
 * overwritten, module and search paths are appended.
 */
LOCAL int ec_configure ()
{
        MinParser     *inifile = INITPTR;
        char           *home_d = getenv ("HOME");
        char           *curr_d = getenv ("PWD");
        char           *def_d = MIN_CONF_DIR;
        char           *min_d;
        int             op_mode = ec_settings.operation_mode_;

        /*Initialize logger settings */
        /*Read settings from global .conf */
        if (curr_d == NULL || strcmp (MIN_CONF_DIR, curr_d) != 0) {
                inifile = mp_create (def_d, "min.conf", ENoComments);

                if (inifile == INITPTR) {
                        MIN_WARN ("Could not open %s/min.conf %s\n",
                                   MIN_CONF_DIR, strerror (errno));
                } else {
                        ec_read_conf (inifile, op_mode);
                        mp_destroy (&inifile);
                }
        }
        /*Read $HOME/.min/min.conf */
        if (home_d != NULL) {
                min_d = NEW2 (char, strlen (home_d) + 7);
                sprintf (min_d, "%s/.min", home_d);
                if (strcmp (min_d, curr_d) != 0) {
                        inifile = mp_create (min_d, "min.conf", ENoComments);
                        
                        if (inifile == INITPTR) {
                                MIN_WARN ("Could not open "
                                             "%s/min.conf %s\n",
                                             min_d, strerror (errno));
                        } else {
                                ec_read_conf (inifile, op_mode);
                                mp_destroy (&inifile);
                        }
                }
                DELETE (min_d);
        } else {
                MIN_WARN ("$HOME == NULL, not reading "
                           "min.conf from ~/.min");
        }
        /*try to read ./min.conf */
        if (curr_d != NULL) {
                inifile = mp_create (curr_d, "min.conf", ENoComments);
                
                if (inifile == INITPTR) {
                        MIN_DEBUG ("Could not open %s/min.conf %s\n", 
                                    curr_d,
                                    strerror (errno));
                } else {
                        ec_read_conf (inifile, op_mode);
                        mp_destroy (&inifile);
                }
        } else {
                MIN_WARN ("$PWD == NULL, not reading "
                           "min.conf from .");
        }

        /*
         ** Read module definitions from /etc/min.d/
         */
        if (op_mode == 0)
                ec_read_module_confdir ();

        return 0;
}

/** Checks if the user configuration dir exists and creates it if not
 */
LOCAL void create_local_confdir ()
{
        struct stat dirstat;
        Text *confpath;
        char *home = getenv ("HOME");
        
        if (home == NULL)
                return;

        confpath = tx_create (home);
        tx_c_append (confpath, "/.min");

        memset (&dirstat, 0, sizeof (struct stat));
        if (stat (tx_share_buf(confpath), &dirstat)) {
                /* directory does not exist, try to create */
                if (mkdir (tx_share_buf(confpath), S_IRWXU)) {
                        MIN_FATAL ("Failed to create %s: %s\n"
                                    "Exiting ...\n",tx_share_buf,
                                    strerror (errno));
                        goto err_exit;
                }
        } 
        /*
        ** Check that the directory has write permissions
        */
        else if (!(dirstat.st_mode & S_IWUSR)) {
                MIN_FATAL ("User does not have write permission to %s\n"
                            "Exiting ...\n", tx_share_buf (confpath));
                
                goto err_exit;
                
        }

        tx_destroy (&confpath);
        return; 
       
err_exit:
        tx_destroy (&confpath);
        ec_cleanup ();
        exit (1);
        return;
}

/**Function initializes all engine's global variables, creates message queues 
 * and threads. In case of problems during operations vital to test execution,
 * function exits process  - since if any of those operations fail - MIN will
 * not be able to work anyway
 * @param completecallbk pointer to function called when test case completes
 * @param printcallbk pointer to function called when test case tries to print
 *         output
 * @param extifsendcallbk pointer to function sending external controller 
 *        messages
 * @param envp pointer to enviroment settings var
 * @param operation_mode - describes what is the operation mode of min
 *         instance - 0 means console interface, 
 *                    1 - external controller interface.
 */
void ec_min_init (min_case_complete_func completecallbk,
                   min_case_print_func printcallbk,
                   min_extif_message_cb_ extifsendcallbk,
                   char *envp_[], int operation_mode)
{
        int             thread_creation_result;
        pthread_t       listener_thread;
        unsigned int    debug_lev = 3;  

        extif_callbacks.complete_callback_ = completecallbk;
        extif_callbacks.print_callback_ = printcallbk;
        extif_callbacks.send_extif_msg_ = extifsendcallbk;

        ec_settings.operation_mode_ = operation_mode;

        envp = envp_;
        

        if (operation_mode == 0)
                create_local_confdir();

        /*
         ** Global data initialization
         */
        memset (&in, 0x0, sizeof(eapiIn_t));
        available_modules = dl_list_create ();
        instantiated_modules = dl_list_create ();
        selected_cases = dl_list_create ();

        /* not sure if this code should be here, but it should work anyway */
        pthread_mutex_lock (&tec_mutex_);
        ec_settings.engine_pid_ = getpid ();
        pthread_mutex_unlock (&tec_mutex_);
        ec_settings.search_dirs = dl_list_create ();
        ec_init_logger_settings ();
        ec_configure ();
        ec_settings_send ();

        min_log_open ("MIN", debug_lev);

        /* results = dl_list_create ( ); */
#ifdef MIN_EXTIF
        ms_assoc = dl_list_create ();
        EXTIF_received_data = dl_list_create ();
#endif
        if ((available_modules == INITPTR)
            || (instantiated_modules == INITPTR)
            || (selected_cases == INITPTR) || (results == INITPTR)) {

                MIN_FATAL ("Not enough memory to create list");
                min_log_close ();
                exit (0);

        }

        mq_id = mq_open_queue ('a');
        if (mq_id < 0) {
                MIN_WARN ("Failed to create message queue: %s",
                           strerror (errno));
                min_log_close ();
                exit (0);
        }
        event_system_init ();


        /*start modules */
        ec_start_modules ();
        /* Listener thread creation */
        long            tmp = 0;
        thread_creation_result =
            pthread_create (&listener_thread, NULL, ec_message_listener,
                            (void *)tmp);
        if (thread_creation_result != 0) {
                MIN_WARN ("Failed to create new thread");
                char           *fault_text = "unspecified problem";
                switch (thread_creation_result) {
                case EAGAIN:
                        fault_text =
                            "Limit of threads in the system exceeded";
                        break;
                case EPERM:
                        fault_text =
                            "Insufficient user rights to create thread";
                        break;
                }
                MIN_FATAL ("%s", fault_text);
                min_log_close ();
                exit (0);
        }

        sl_set_sighandler (SIGSEGV, handle_sigsegv);
        sl_set_sighandler (SIGTERM, handle_sigterm);
        sl_set_sighandler (SIGBUS, handle_sigbus);
        sl_set_sighandler (SIGQUIT, handle_sigquit);
        sl_set_sighandler (SIGINT, handle_sigint);
}

LOCAL void handle_sigsegv (int signum)
{
        raise (SIGQUIT);
}

LOCAL void handle_sigquit (int signum)
{
        ec_cleanup ();
        exit (1);
}

LOCAL void handle_sigbus (int signum)
{
        raise (SIGQUIT);
}

LOCAL void handle_sigterm (int signum)
{
        ec_cleanup ();
        exit (0);
}

LOCAL void handle_sigint (int signum)
{
        ec_cleanup ();
        exit (0);
}

/* ======================== FUNCTIONS ====================================== */
/**Function called to execute one selected test case.
 * It adds test case to selected test cases list, sets its status to ongoing
 * and group id to 0, since it does not belong to group. Also, it adds
 * new item to test case's results list.Function Sets module status to busy, 
 * then creates and sends MSG_EXE using data fetched from test case and 
 * module info
 * @param work_case_item pointer to list itemwith case to be executed
 * @return result of operation(TBD)
 */
int ec_exec_test_case (DLListIterator work_case_item)
{
        int             result = 0;
        pthread_mutex_lock (&tec_mutex_);
	/*add to selected cases list */
        work_case_item = ec_select_case (work_case_item, 0);

        pthread_mutex_unlock (&tec_mutex_);
        result = ec_exec_case (work_case_item);

        return result;
}


/** Function called by UI to pause execution of selected test case.
 * @param work_case_item pointer to dl_list_item containig selected test case.
 * @return result of operation :0 if message was sent successfully, -1 in case
 *        of data or message queue error, -2 if case is already paused,
 *        -3 if case is not running
*/
int ec_pause_test_case (DLListIterator work_case_item)
{
        DLListIterator  work_module_item;
        int             result = 0;
        int             case_status = tc_get_status (work_case_item);
        long            addr = 0;

        switch (case_status) {
        case TEST_CASE_ONGOING:
                work_module_item = tc_get_test_module_ptr (work_case_item);
                addr = tm_get_pid (work_module_item);
                result = mq_send_message2 (mq_id, addr, MSG_PAUSE, 0, "\0");
                if (result == 0)
                        tc_set_status (work_case_item, TEST_CASE_PAUSED);
                break;
        case TEST_CASE_PAUSED:
                result = -2;
                break;
        default:
                result = -3;
        }

        return result;
}


/** Function called by UI to resume execution of previously paused case:
* @param work_case_item pointer to dl_list_item containing selected test case
* @return : result of operation: 0 if message was sent successfully, 
*                               -1 in case of data or message queue error,
*                               -2 if case was not paused, 
*                               -3 if case is not running (not started or
*                                  already finished).
*/
int ec_resume_test_case (DLListIterator work_case_item)
{
        DLListIterator  work_module_item;
        int             result = 0;
        int             case_status = tc_get_status (work_case_item);
        long            addr = 0;

        switch (case_status) {
        case TEST_CASE_PAUSED:
                work_module_item = tc_get_test_module_ptr (work_case_item);
                addr = tm_get_pid (work_module_item);
                result = mq_send_message2 (mq_id, addr, MSG_RESUME, 0, "\0");
                if (result == 0) {
                        tc_set_status (work_case_item, TEST_CASE_ONGOING);
                }
                break;
        case TEST_CASE_ONGOING:
                result = -2;
                break;
        default:
                result = -3;
                break;
        }

        return result;
}


/**Function called byu UI to stop test case execution.
* @param work_case_item pointer to dl_list_item containing selected test case
* @return result of operation: 0 if message was sent successfully, -1 in case
* of data or message queue error, -2 if case has already finished execution.
*/
int ec_abort_test_case (DLListIterator work_case_item)
{
        DLListIterator  work_module_item;
        int             result = 0;
        int             case_status = tc_get_status (work_case_item);
        long            addr = 0;

        switch (case_status) {
        case TEST_CASE_PAUSED:
        case TEST_CASE_ONGOING:
                work_module_item = tc_get_test_module_ptr (work_case_item);
                addr = tm_get_pid (work_module_item);
                result = mq_send_message2 (mq_id, addr, MSG_STOP, 0, "\0");
                break;
        case TEST_CASE_TERMINATED:
                result = -2;
                break;
        default:
                result = -1;
        }

        return result;
}
/* ------------------------------------------------------------------------- */
/** Function that takes care of removal of all created objects, freeing
 * memory and so on.
 */
void ec_cleanup ()
{
        long            address;
#ifdef MIN_EXTIF
        DLListIterator  work_slave_item;
        DLListIterator  work_data_item;
        received_data  *work_data_entry;
#endif
        DLListIterator  work_module_item;
        DLListIterator  work_module_item2;
        DLListIterator  work_case_item;
        DLListIterator  work_case_item2;
        test_case_s    *work_case = INITPTR;
        DLList         *work_list;

        event_system_cleanup ();
#ifdef MIN_EXTIF
        log_summary_stdout ();
        work_slave_item = dl_list_head (ms_assoc);
        while (work_slave_item != DLListNULLIterator) {
                dl_list_remove_it (work_slave_item);
                work_slave_item = dl_list_head (ms_assoc);
        }
        dl_list_free (&ms_assoc);

        work_data_item = dl_list_head (EXTIF_received_data);
        while (work_data_item != DLListNULLIterator) {
                work_data_entry =
                    (received_data *) dl_list_data (work_data_item);
                DELETE (work_data_entry);
                dl_list_remove_it (work_data_item);
                work_data_item = dl_list_head (EXTIF_received_data);
        }
        dl_list_free (&EXTIF_received_data);

#endif
        work_module_item = dl_list_head (instantiated_modules);
	/*shutdown all running tmcs and free list*/
        while (work_module_item != DLListNULLIterator) {
                address = tm_get_pid (work_module_item);
                mq_send_message2 (mq_id, address, MSG_END, 0, "Shut down !");
                waitpid (address, NULL, 0);
                /*we suppose that sending this message to TMC will ensure
                   that it shuts down properly */
                work_module_item2 = dl_list_next (work_module_item);
                tm_remove (work_module_item);
                work_module_item = work_module_item2;
        }

        /*
	 * now free all memory used for data
	 */
        work_module_item = dl_list_head (instantiated_modules);
        while (work_module_item != DLListNULLIterator) {
                work_module_item2 = dl_list_next (work_module_item);
                work_list = tm_get_tclist (work_module_item);
                work_case_item = dl_list_head (work_list);
                while (work_case_item != DLListNULLIterator) {
                        work_case_item2 = dl_list_next (work_case_item);
                        tc_delete ((test_case_s *)
                                   dl_list_data (work_case_item));
                        tc_remove (work_case_item);
                        work_case_item = work_case_item2;
                }
                tm_delete ((test_module_info_s *)
                           dl_list_data (work_module_item));
                tm_remove (work_module_item);
                work_module_item = work_module_item2;
        }
        dl_list_free (&instantiated_modules);

        work_module_item = dl_list_head (available_modules);
        while (work_module_item != DLListNULLIterator) {
                work_module_item2 = dl_list_next (work_module_item);
                work_list = tm_get_tclist (work_module_item);
                work_case_item = dl_list_head (work_list);
                while (work_case_item != DLListNULLIterator) {
                        work_case_item2 = dl_list_next (work_case_item);
                        tc_delete ((test_case_s *)
                                   dl_list_data (work_case_item));
                        work_case =
                            (test_case_s *) dl_list_data (work_case_item);
                        tc_remove (work_case_item);
                        work_case_item = work_case_item2;
                }
                tm_delete ((test_module_info_s *)
                           dl_list_data (work_module_item));
                tm_remove (work_module_item);
                work_module_item = work_module_item2;
        }
        dl_list_free (&available_modules);

        work_case_item = dl_list_head (selected_cases);
        while (work_case_item != DLListNULLIterator) {
                work_case = (test_case_s *) dl_list_data (work_case_item);
                tc_remove (work_case_item);
                tc_delete (work_case);
                work_case_item = dl_list_head (selected_cases);
        }
        dl_list_free (&selected_cases);


        dl_list_free_data (&ec_settings.search_dirs);
        dl_list_free (&ec_settings.search_dirs);

        /* This sleep period allows for handling of all sent messages before
	 * destroying message queue 
	 */
        usleep (50000);
        sm_destroy (ec_settings.sh_mem_id_);
        mq_close_queue (mq_id);
        min_log_close();
        usleep (30000);
}

/**Function called by user (external controller or console IF) to execute 
 * sequence of test cases
 * @param work_cases_list list of test cases to be executed - user has to build
 * list of test cases by himself.
 */
int ec_run_cases_seq (DLList * work_cases_list)
{
        DLListIterator  work_case_item = dl_list_head (work_cases_list);
        DLListIterator  exec_case = DLListNULLIterator;
        int             group_id = random ();   /* generate unique group id */

        if (work_case_item == DLListNULLIterator) {
                MIN_WARN ("Invalid list of test cases passed !");
                return -1;
        }
        pthread_mutex_lock (&tec_mutex_);

        /*we mark first case of the group to be executed */
        exec_case = ec_select_case (work_case_item, group_id);
        work_case_item = dl_list_next (work_case_item);
        /*now we will iterate through the remaining cases in received list */
        while (work_case_item != DLListNULLIterator) {
                ec_select_case (work_case_item, group_id);
                work_case_item = dl_list_next (work_case_item);
        }
        pthread_mutex_unlock (&tec_mutex_);

        /*now we need to clear passed list, so we don't leave any garbage
           behind. The list itself cannot be destroyed,because it is
           console's global variable. This can change, though. */
        work_case_item = dl_list_head (work_cases_list);
        while (work_case_item != DLListNULLIterator) {
                dl_list_remove_it (work_case_item);
                work_case_item = dl_list_head (work_cases_list);
        }
        /*all done, now start execution of group with first case */
        ec_exec_case (exec_case);
        return 0;
}




int ec_run_cases_par (DLList * work_cases_list)
{
        DLListIterator  work_case_item = dl_list_head (work_cases_list);
        DLListIterator  exec_case = DLListNULLIterator;
        int             group_id = random ();   /* generate unique group id */

        if (work_case_item == DLListNULLIterator) {
                MIN_WARN ("Invalid list of test cases passed !!");
                return -1;
        }
        pthread_mutex_lock (&tec_mutex_);

        /*"select" all cases in received list */
        while (work_case_item != DLListNULLIterator) {
                exec_case = ec_select_case (work_case_item, group_id);
                ec_exec_case (exec_case);
                work_case_item = dl_list_next (work_case_item);
        }
        pthread_mutex_unlock (&tec_mutex_);

        /*now we need to clear passed list, so that we don't leave any garbage
           behind. The list itself cannot be destroyed,because it is
           console's global variable. This can change, though. */
        work_case_item = dl_list_head (work_cases_list);
        while (work_case_item != DLListNULLIterator) {
                dl_list_remove_it (work_case_item);
                work_case_item = dl_list_head (work_cases_list);
        }

        return 0;
}

/**Function used to add test module to MIN framework at any time.
 * @param mod_name name of module to be added
 * @param testcase_files list containing names of testcasefiles associated
 * with module.
 * @param id test module identifier
 * @return result of operation: WARNING: function fails if there is problem 
 * with initializing data for module entity, possibly some memory problem, or
 * if any of specified files does not exist. Information, if module was 
 * started successfully, (returned test cases) is not available. Indication of
 * problems of
 * that kind would  be failure to start case from that module later.
 */
int ec_add_module (TSChar * mod_name, DLList * testcase_files, 
                   test_module_id_t  id)
{
        DLListIterator  work_module_item = DLListNULLIterator;
        test_module_info_s *work_module = INITPTR;
        pid_t           result = 0;
        int             retval = -1;

        work_module = tm_create (mod_name, testcase_files, id);
        if (work_module == INITPTR)
                goto FAULT;
        work_module_item = tm_add (available_modules, work_module);
        result = ec_start_tmc (work_module_item);
        ec_init_module_data (work_module_item);
        if (result > 0) {
                pthread_mutex_lock (&tec_mutex_);
                tm_add (instantiated_modules, work_module);
                pthread_mutex_unlock (&tec_mutex_);
                retval = 0;
        } else {
                retval = -1;
        }

      FAULT:
        return retval;
}


/**Function searches defined library search paths for library with given name
 * @param name of file to be found
 * @return position of correct path on search paths list, or -1 if file is
 *         not found.
 */
int ec_search_lib (char *mod_name)
{
        char           *full_path = NULL;
        DLListIterator  work_path_item = DLListNULLIterator;
        int             result = 666;
        int             pos = 0;
        char           *work_path = NULL;
        int             retval = -1;

        for (pos = 0; pos < dl_list_size (ec_settings.search_dirs); pos++) {
                work_path_item = dl_list_at (ec_settings.search_dirs, pos);
                work_path = (char *)dl_list_data (work_path_item);
                full_path =
                    NEW2 (char, strlen (work_path) + strlen (mod_name) + 2);
                sprintf (full_path, "%s/%s", work_path, mod_name);
                result = access (full_path, F_OK);
                DELETE (full_path);
                if (result == 0) {
                        retval = pos;
                        break;
                }
        }

        return retval;
}

/* ------------------------------------------------------------------------- */
int ec_read_settings (char *engine_ini)
{
        MinParser     *passed_config = INITPTR;
        char           *out = NULL;
        char           *fname = NULL;
        char           *dir = NULL;
        int             cont_flag = 0;
        int             status = 0;
        int             result = 0;
        int             i = 0;
        DLListIterator  work_module_item = DLListNULLIterator;
        char           *temp = engine_ini;

        do {
                out = &temp[1];
                temp = strchr (out, '/');
        } while (temp != NULL);

        fname = out;
        dir = NEW2 (char, strlen (engine_ini) - strlen (fname));
        strncpy (dir, engine_ini, strlen (engine_ini) - strlen (fname) - 1);
        dir[strlen (engine_ini) - strlen (fname) - 1] = '\0';
        printf (" read : %s | %s \n", dir, fname);
        passed_config = mp_create (dir, fname, ENoComments);
        ec_read_conf (passed_config, 0);
        /*in case settings shared memory segment exists already, destroy it */
        sm_destroy (ec_settings.sh_mem_id_);
        /*now send new settings */
        ec_settings_send ();

        ec_start_modules ();
        while (cont_flag == 0) {
                usleep (500000);
                i++;
                work_module_item = dl_list_head (instantiated_modules);
                cont_flag = 1;
                while (work_module_item != DLListNULLIterator) {
                        status = tm_get_status (work_module_item);
                        if (status == TEST_MODULE_READY)
                                cont_flag = cont_flag | 1;
                        else
                                cont_flag = 0;
                        work_module_item = dl_list_next (work_module_item);
                }
                if (i > 20) {
                        result = -1;
                        break;
                };
        }

        return result;
}

/* ================= OTHER EXPORTED FUNCTIONS ============================== */
/* None */


/* ================= TESTS FOR LOCAL FUNCTIONS ============================= */
#ifdef MIN_UNIT_TEST
#include "tec.tests"
#endif                          /* MIN_UNIT_TEST */

/* End of file */
